// Primitive data
#define b1 (\t \f f)
#define b0 (\t \f t)
#define T (\x \y x)
#define F (\x \y y)
#define nil F
#define C (\x \y \p p x y)
#define Y (\f ((\x x x) (\x f (x x))))
#define uncurry (\f \c f (c T) (c F))
#define fdot (\f \g \a f (g a))

// Byte
#define B (\a \b \c \d \e \f \g \h (C a (C b (C c (C d (C e (C f (C g (C h nil)))))))))

// IO
#define H (B b0 b1 b0 b0 b1 b0 b0 b0)
#define E (B b0 b1 b1 b0 b0 b1 b0 b1)
#define L (B b0 b1 b1 b0 b1 b1 b0 b0)
#define O (B b0 b1 b1 b0 b1 b1 b1 b1)
#define S (B b0 b0 b1 b0 b0 b0 b0 b0)
#define nl (B b0 b0 b0 b0 b1 b0 b1 b0)
#define Null (B b0 b0 b0 b0 b0 b0 b0 b0)
#define Zero (B b0 b0 b1 b1 b0 b0 b0 b0)
#define C6 (\a \b \c \d \e \f \g C a (C b (C c (C d (C e (C f g))))))

// Logical functions
#define id (\a a)
#define not (\a C F T a)
#define and (\a \b C a F b)
#define nor (\a \b C F (not a) b)
#define or (\a \b C T a b)
#define xor (\a \b C (not a) a b)

// List functions
#define map_step (\fix \f \l l (\x \xs \_ C (f x) (fix f xs)) nil)
#define map (Y map_step)
#define zip_step (\fix \l \m l (\x \xs \_ m (\y \ys \_ C (C x y) (fix xs ys)) nil) nil)
#define zip (Y zip_step)
#define zipWith (\f \l \m map (\c c f) (zip l m)) // TODO: in point-free style (with the function composition operator)
#define foldl_step (\fix \f \a \l l (\x \xs \_ fix f (f a x) xs) a)
#define foldl (Y foldl_step)
#define foldr_step (\fix \f \a \l l (\x \xs \_ f x (fix f a xs)) a)
#define foldr (Y foldr_step)
#define append_step (\fix \l \m l (\x \xs \_ C x (fix xs m)) m)
#define append (Y append_step)

// Binary arithmetics
#define xors  (zipWith xor)
#define atleast2 (\a \b \c or (or (and a b) (and a c)) (and b c))

// Numbers
#define n0 (B b0 b0 b0 b0 b0 b0 b0 b0)
#define n1 (B b0 b0 b0 b0 b0 b0 b0 b1)
#define n2 (B b0 b0 b0 b0 b0 b0 b1 b0)
#define n3 (B b0 b0 b0 b0 b0 b0 b1 b1)
#define n4 (B b0 b0 b0 b0 b0 b1 b0 b0)
#define n5 (B b0 b0 b0 b0 b0 b1 b0 b1)
#define n6 (B b0 b0 b0 b0 b0 b1 b1 b0)
#define n7 (B b0 b0 b0 b0 b0 b1 b1 b1)
#define n8 (B b0 b0 b0 b0 b1 b0 b0 b0)
#define n9 (B b0 b0 b0 b0 b1 b0 b0 b1)
#define carry (\ab \c C (uncurry atleast2 ab c) (xor (uncurry xor ab) c))

#define add_u8_carry (\l \m foldr (\b \acc C (carry b (acc T) T) (C (carry b (acc T) F) (acc F))) (C b0 F) (zip l m))
#define add_u8 (\l \m add_u8_carry l m F)
#define neg_u8 (map not)
#define inc_u8 (add_u8 n1)
#define sub_u8 (\a \b add_u8 (inc_u8 a) (neg_u8 b))

// #define lshift_u8 ()

#define print_b (\b C (B b0 b1 b0 b1 b0 b1 b0 b0) (B b0 b1 b0 b0 b0 b1 b1 b0) b)
#define print_B (map (\x (B b0 b0 b1 b1 b0 b0 b0 x)))
#define print_digit (\n add_u8 Zero n)
// #define print_u8 (\n add_u8 Zero n)

\i (append (C6 H E L L O S nil) (C6 H E L L O S (C (print_digit (sub_u8 n9 n9)) (C nl nil))))
